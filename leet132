/**
 * @param {string} s
 * @return {number}
 */
var minCut = function (s) {
    // 使用HASH 保留一个字母出现的位置  hash  {  1:[1,2,3],  d:[4,5],  e:[]  }， 快速找到可能的回文

    /**
     * 1. 判断并存储所有的回文字符串， 以左开始为 key :  {1: [1,2], 2:[2,4] ,3:[3,6],4:[4], 5:[5,6], 6:[6] }
     * 找出所有的回文 index
     */


        // 字母 - [位置] hash
    let charPos = {};
    for (let i = 0; i < s.length; i++) {
        if (charPos[s[i]]) {
            charPos[s[i]].push(i);
        } else {
            charPos[s[i]] = [i];
        }
    }
    // console.log('charPos:::',charPos)

    // 初始回文hash
    let revs = {};
    for (let i = 0; i < s.length; i++) {
        revs[i] = [i];
    }

    // 快速检查回文
    for (let i = 0; i < s.length; i++) {
        const ch = s[i];
        const poss = charPos[ch];

        for (const pos of poss) {
            if (pos > i) {
                chkRe(i, pos);
            }
        }
    }

    /**
     * 快速生成回文状态表
     * 回文标记， 二维   reArr[2][3] 表示  str[2,3] 是否为回文字符串
     *[[1,0,0,0,0,0,0],
     * [0,1,0,0,0,0,0],
     * [0,0,1,0,0,0,0],
     * [0,0,0,1,0,0,0],
     * [0,0,0,0,1,0,0],
     * [0,0,0,0,0,1,0],
     * [0,0,0,0,0,0,1]]
     */

    // 初始化回文表
    let reArr =[]
    for (let i = 0; i < s.length; i++) {
        reArr[i] = [];
        for (let j = 0; j < s.length; j++) {
            if (j === i ){
                reArr[i].push(1);
            }else{
                if (chkRe(i,j)){
                    reArr[i].push(1);
                    if (j>i){
                        revs[i].push(j)
                    }
                }else{
                    reArr[i].push(0);
                }
            }
        }
    }
    function chkRe(l, r) {
        if (l>r){
            return chkRe(r,l);
        }
        if (l === r){
            return true;
        }
        if (r === l+1){
            return s[l] === s[r];
        }
        return chkRe(l+1, r-1) && s[l]===s[r]
    }

    /**
     * 2. 生成树并通过BFS 求得最短路径，就是最小的分割次数
     */


    if (chkRe(0,s.length-1)){
        return 0;
    }


    let level = 0;
    let queue = [];
    let found = false;
    let visited = new Set();
    queue.unshift(0);

    while (queue.length > 0) {
        const size = queue.length;
        level++;

        // 遍历同层的节点
        for (let i = 0; i < size; i++) {
            // 获取一个节点，
            const pt = queue.pop();

            // 找到结束点，说明已经结束
            if (pt >= s.length - 1) {
                // console.log('bningo');
                found = true;
                break;
            }

            // 将子节点的下一个分割后的节点压入栈 如 5:[5,7,8], 则压入的节点为 [6,8,9]
            const revpoints = revs[pt];
            for (let j = 0; j < revpoints.length; j++) {
                if (!visited.has(Number(revpoints[j]))){
                    queue.unshift(Number(revpoints[j]) + 1);
                    visited.add(Number(revpoints[j]));
                }
            }
        }
        if (found) {
            break;
        }
    }
    return level-1;
};
